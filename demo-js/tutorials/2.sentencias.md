# Sentencias de cÃ³digo

- Expresiones. Operadores

  - Operadores de asignaciÃ³n
  - Operadores aritmÃ©ticos
  - Operadores de comparaciÃ³n
  - Casting y coercion
  - Casos pintorescos de coercion
  - Coercion a boolean

- Sentencias de control (ver 03)

## Expresiones. Operadores

Como ya sabemos, las sentencias de JS pueden incorporar **expresiones**. Tas es el caso de las sentencias de asignaciÃ³n o de las condicione que aparecerÃ¡n en las sentencias de control que luego veremos.

Una expresiÃ³n puede incluir literales, variables y operadores y siempre se evalÃºa a un **Ãºnico valor**.

Existen distintos tipos de operadores

- operadores de asignaciÃ³n
- operadores aritmÃ©ticos
- operadores de comparaciÃ³n
- operadores bit a bit
- operadores lÃ³gicos
- operadores de cadena
- operador condicional (ternario)
- operador coma
- operadores unarios
- operadores relacionales

### Operadores de asignaciÃ³n

Como ya sabemos el operador de **asignaciÃ³n** es el simbolo **igual** (=)

---

ğŸ¥·Existen ademÃ¡s una serie de operadores que combinan la asignaciÃ³n con una operaciÃ³n aritmÃ©tica escribiÃ©ndolo de forma abreviada. Excepto el primero, no se usan mucho y por el momento ppuedes olvidarte de ellos

- asignaciÃ³n de adiciÃ³n x += y (x = x + y)
- asignaciÃ³n de resta x -= y (x = x - y)
- asignaciÃ³n de multiplicaciÃ³n x _= y (x = x /_ y)
- asignaciÃ³n de divisiÃ³n x /= y (x = x / y)
- asignaciÃ³n de resto x %= y (x = x % y)
- asignaciÃ³n de exponenciaciÃ³n x \*_= y (x = x /_/\* y)

---

### Operadores aritmÃ©ticos

Operaciones aritmÃ©ticas estÃ¡ndar

- suma (+)
- resta (-)
- producto (\*)
- divisiÃ³n (/)
- resto o mÃ³dulo (%)
- exponente (\*\*)
- signo positivo (+)
- signo negativo (-)

Otros aritmÃ©ticos mutables, que modifican la variable a la que se aplican

- incremento (++)
- decremento (--)

```js
const num = 3;
console.log(num + num); // 6
console.log(num - num); // 0
console.log(num * num); // 9
console.log(num / num); // 1
console.log(num % num); // 0
console.log(num ** num); // 27
console.log(+num); // 3
console.log(-num); // -3

let num1 = 3;
num1++;
console.log(num1); // 4
num1--;
console.log(num1); // 3
```

### Operadores de comparaciÃ³n

Como su nombre indica comparan dos valores y devuelven un valor lÃ³gico (boolean), true o false, en funciÃ³n del resultado.

Comparaciones de igualdad

- Igual (==). Devuelve true si los operandos son iguales.
- No es igual (!=). Devuelve true si los operandos no son iguales.
- Estrictamente igual (===). Devuelve true si los operandos son iguales y del mismo tipo.
- Desigualdad estricta (!==). Devuelve true si los operandos son del mismo tipo pero no iguales, o son de diferente tipo.

```js
const foo = 3;
const bar = 4;
// Igualdad
console.log(3 == foo); // true
console.log('3' == foo); // true
console.log(3 == '3'); // true
console.log(foo != 4); // true
console.log(bar != '3'); // true
// Igualdad estricta
console.log(3 === foo); // true
console.log(foo !== '3'); // true
console.log(3 !== '3'); // true
```

Mayor o menor

- Mayor que (>)
- Mayor o igual que (>=)
- Menor que (<)
- Menor o igual (<=)

```js
const foo = 3;
const bar = 4;
console.log(bar > foo); // true
console.log('12' > 2); // true
console.log(bar >= foo); // true
console.log(foo >= 3); // true
console.log(foo < bar); // true
console.log('2' < 12); // true
console.log(foo <= bar); // true
```

Para entender el funcionamiento de los operadores en relaciÃ³n con los tipos tenemos que mencionar los conceptos de casting y coercion.

### Casting y coercion

Casting es el proceso de utilizaciÃ³n durante una determinada operaciÃ³n del equivalente a una variable cambiÃ¡ndole el tipo, con el fin de poder llevar a cabo la operaciÃ³n. Dicho de otra manera, es la acciÃ³n de forzar a que una variable se comporte como si fuera de otro tipo.

Este proceso puede ser

- explÃ­cito, cuando se indica en el cÃ³digo que se debe producir. Se suele denominar casting
- implÃ­cito, cuando lo realiza automÃ¡ticamente el lenguaje. Se suele denominar coercion. En JS este proceso se realiza siempre que resulta necesario para que se pueda evaluar una expresiÃ³n.

Veamos un ejemplo para terminar de entender el proceso.

```js
const foo = 12; // tipo number
const bar = '3'; // tipo string

const result = foo / bar;

// La divisiÃ³n solo tiene sentido entre dos operadores numÃ©ricos
// JS aplica sus reglas de coercion y en lugar del valor real de bar utiliza su equivalente numÃ©rico 3
// De esta forma puede evaluar la expresiÃ³n 12/3 a 4 y asignar el resultado a result

console.log(result, typeof result); // 4 number

// Como puedes ver ni foo ni bar han cambiado ni de valor ni de tipo
console.log(foo, typeof foo); // 12 number
console.log(bar, typeof bar); // 3 string
```

En algunos casos las reglas de coercion no dan el resultado esperado y es necesario emplear un casting explicito para corregirlas. De momento basta con que sepas que estos procesos existen.

### Casos pintorescos de coercion

Pese a lo que acabamos de decir, hay un par de situaciones de JS que pueden resultar sorprendentes y que vamos a comentar

El primero de ellos se refiere al **operador +**, que incluye tanto las suma como la concatenaciÃ³n, pero da prioridad a esta Ãºltima.

```js
const foo = 3;
const bar = '4';
const result = foo + bar;
console.log(result, typeof result); // 34 string
```

Para evitar esta situaciÃ³n podemos emplear el **casting explicito** a number:

- con la funciÃ³n de casting Number()
- aplicando el operador de signo +

```js
const foo = 3;
const bar = '4';
let result = foo + bar;
console.log(result, typeof result); // 34 string
result = foo + Number(bar);
console.log(result, typeof result); // 7 number
result = foo + +bar;
console.log(result, typeof result); // 7 number
```

El segundo caso se refiere a la **coercion a number de los string**. Con un string numÃ©rico no hay problema: en lugar de '9' usamos el nÃºmero 9. Pero, Â¿como puede JS calcular el numero equivalente a un string que no se refiere a nÃºmeros?. Para eso existe una entidad especial, dentro del conjunto de los valores de tipo number, conocida como **NaN** (not-a-number) que representa un nÃºmero cuyo valor es indeterminado.

Aunque matemÃ¡ticamente existen la indeterminaciones, en la prÃ¡ctica suele ser poco util un valor Nan. Ya aprenderÃ¡s como programamos para evitas que aparezcan valores NaN

### Coercion a boolean

El caso mÃ¡s llamativo en que JS realiza la coercion automÃ¡tica es cuando se espera un boolean, como en las condiciones de if o the while que luego veremos. En esta situaciÃ³n cualquier variable se convierte a true, y se denomina **truthy**, excepto unos pocos valores conocidos como **falsy**

- false
- 0, -0 y 0n (el bigInt 0)
- undefined
- null
- NaN (el numero indeterminado, not-a-number)
- '' (el string vacÃ­o)

Para que compruebes esta conversiÃ³n podemos usar la funciÃ³n de casting explicito Boolean

```js
console.log(Boolean(false)); // false
console.log(Boolean(null)); // false
console.log(Boolean(undefined)); // false
console.log(Boolean(0)); // false
console.log(Boolean(-0)); // false
console.log(Boolean(0n)); // false
console.log(Boolean(NaN)); // false
console.log(Boolean('')); // false
```

> ğŸ› ï¸ Si pruebas cualquier otro valor, veras que se evalÃºa a true
